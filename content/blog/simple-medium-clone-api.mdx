---
title: 'Building a REST API with Nest.js and Prisma'
publishedAt: '2024-04-24'
lang: 'en'
author: 'Sher Arbaev'
summary: 'In this tutorial, you will learn how to build the backend REST API for a blog application called "Median" (a simple Medium clone). You will get started by creating a new NestJS project. Then you will start your own PostgreSQL server and connect to it using Prisma. Finally, you will build the REST API and document it with Swagger.'
---

#### Technologies you will use

You will be using the following tools to build this application:

- [**Nest.js**](https://nestjs.com/) as the backend framework

- [**Prisma**](https://www.prisma.io/) as the Object-Relational Mapper (ORM)

- [**PostgreSQL**](https://www.postgresql.org/) as the database

- [**Swagger**](https://swagger.io/) as the API documentation tool

- [**TypeScript**](https://www.typescriptlang.org/) as the programming language

# Prerequisites

#### Assumed knowledge

This is a beginner friendly tutorial. However, this tutorial assumes:

- **Basic** knowledge of JavaScript or TypeScript (preferred)

- **Basic** knowledge of Nest.js

> Note: If you're not familiar with Nest.js, you can quickly learn the basics by following the [overview section](https://docs.nestjs.com/first-steps) in the Nest.js docs.

#### Development environment

To follow along with this tutorial, you will be expected to:

- ... **have** [Node.js](https://nodejs.org/) installed.

- ... **have** [Docker](https://www.docker.com/) or [PostgreSQL](https://www.postgresql.org/) installed.
- ... **have** the [Prisma VSCode Extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) installed. (optional)
- ... **have** access to a Unix shell (like the terminal/shell in Linux and macOS) to run the commands provided in this series. (optional)

> Note 1: The optional Prisma VSCode extension adds some really nice IntelliSense and syntax highlighting for Prisma.

> Note 2: If you don't have a Unix shell (for example, you are on a Windows machine), you can still follow along, but the shell commands may need to be modified for your machine.

# Generate the Nest.js Project

The first thing you will need is to install the NestJS CLI. The NestJS CLI comes in very handy when working with a NestJS project. It comes with built-in utilities that help you initialize, develop and maintain your NestJS application.

You can use the NestJS CLI to create an empty project. To start, run the following command in the location where you want the project to reside:

```bash
npx @nestjs/cli new median
```

The CLI will prompt you to choose a package manager for your project â€” choose npm. Afterward, you should have a new Nest.js project in the current directory.

Open the project in your preferred code editor (we recommend VSCode). You should see the following files:

```bash
median
  â”œâ”€â”€ node_modules
  â”œâ”€â”€ src
  â”‚   â”œâ”€â”€ app.controller.spec.ts
  â”‚   â”œâ”€â”€ app.controller.ts
  â”‚   â”œâ”€â”€ app.module.ts
  â”‚   â”œâ”€â”€ app.service.ts
  â”‚   â””â”€â”€ main.ts
  â”œâ”€â”€ test
  â”‚   â”œâ”€â”€ app.e2e-spec.ts
  â”‚   â””â”€â”€ jest-e2e.json
  â”œâ”€â”€ README.md
  â”œâ”€â”€ nest-cli.json
  â”œâ”€â”€ package-lock.json
  â”œâ”€â”€ package.json
  â”œâ”€â”€ tsconfig.build.json
  â””â”€â”€ tsconfig.json
```

Most of the code you work on will reside in the `src` directory. The Nest.js CLI has already created a few files for you. Some of the notable ones are:

- `src/app.module.ts`: The root module of the application.

- `src/app.controller.ts`: A basic controller with a single route: `/`. This route will return a simple `'Hello World!'` message.

- `src/main.ts`: The entry point of the application. It will start the Nest.js application.

You can start your project by using the following command:

```bash
npm run start:dev
```

This command will watch your files, automatically recompiling and reloading the server whenever you make a change. To verify the server is running, go to the URL `http://localhost:3000/`. You should see an empty page with the message `'Hello World!'`.

> Note: You should keep the server running in the background as you go through this tutorial.

# Create a PostgreSQL instance

You will be using PostgreSQL as the database for your Nest.js application. This tutorial will show you how to install and run PostgreSQL on your machine through a Docker container.

> Note: If you don't want to use Docker, you can [set up a PostgreSQL instance natively](https://www.prisma.io/dataguide/postgresql/setting-up-a-local-postgresql-database) or get a [hosted PostgreSQL database on Heroku](https://dev.to/prisma/how-to-setup-a-free-postgresql-database-on-heroku-1dc1).

First, create a `docker-compose.yml` file in the main folder of your project:

```bash
touch docker-compose.yml
```

This `docker-compose.yml` file is a configuration file that will contain the specifications for running a docker container with PostgreSQL setup inside. Create the following configuration inside the file:

```bash
# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:13.5
    restart: always
    environment:
      - POSTGRES_USER=myuser
      - POSTGRES_PASSWORD=mypassword
    volumes:
      - postgres:/var/lib/postgresql/data
    ports:
      - '5432:5432'
volumes:
  postgres:
```

A few things to understand about this configuration:

- The `image` option defines what Docker image to use. Here, you are using the `postgres image` version 13.5.

- The `environment` option specifies the environment variables passed to the container during initialization. You can define the configuration options and secrets â€“ such as the username and password â€“ the container will use here.

- The `volumes` option is used for persisting data in the host file system.

- The `ports` option maps ports from the host machine to the container. The format follows a `'host_port:container_port'` convention. In this case, you are mapping the port `5432` of the host machine to port `5432` of the `postgres` container. `5432` is conventionally the port used by PostgreSQL.

Make sure that nothing is running on port `5432` of your machine. To start the `postgres` container, open a new terminal window and run the following command in the main folder of your project:

```bash
docker-compose up
```

If everything worked correctly, the new terminal window should show logs that the database system is ready to accept connections. You should see logs similar to the following inside the terminal window:

```bash
...
postgres_1  | 2022-03-05 12:47:02.410 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
postgres_1  | 2022-03-05 12:47:02.410 UTC [1] LOG:  listening on IPv6 address "::", port 5432
postgres_1  | 2022-03-05 12:47:02.411 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
postgres_1  | 2022-03-05 12:47:02.419 UTC [1] LOG:  database system is ready to accept connections
```

Congratulations ðŸŽ‰. You now have your own PostgreSQL database to play around with!

> Note: If you close the terminal window, it will also stop the container. You can avoid this if you add a `-d` option to the end of the command, like this: `docker-compose up -d`. This will indefinitely run the container in the background.

# Set up Prisma

Now that the database is ready, it's time to set up Prisma!

#### Initialize Prisma

To get started, first install the Prisma CLI as a development dependency. The Prisma CLI will allow you to run various commands and interact with your project.

```bash
npm install -D prisma
```

You can initialize Prisma inside your project by running:

```bash
npx prisma init
```

This will create a new `prisma` directory with a `schema.prisma` file. This is the main configuration file that contains your database schema. This command also creates a `.env` file inside your project.

#### Set your environment variable

Inside the `.env` file, you should see a `DATABASE_URL` environment variable with a dummy connection string. Replace this connection string with the one for your PostgreSQL instance.

```bash
# .env
DATABASE_URL="postgres://myuser:mypassword@localhost:5432/nestjs-db"
```

> Note: If you didn't use docker (as shown in the previous section) to create your PostgreSQL database, your connection string will be different from the one shown above. The connection string format for PostgreSQL is available in the [Prisma Docs](https://www.prisma.io/docs/orm/overview/databases/postgresql#connection-url).

#### Understand the Prisma schema

If you open `prisma/schema.prisma`, you should see the following default schema:

```ts
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

This file is written in the ~Prisma Schema Language~, which is a language that Prisma uses to define your database schema. The `schema.prisma` file has three main components:

- **Data source**: Specifies your database connection. The above configuration means that your database provider is PostgreSQL and the database connection string is available in the `DATABASE_URL` environment variable.

- **Generator**: Indicates that you want to generate Prisma Client, a type-safe query builder for your database. It is used to send queries to your database.

- **Data model**: Defines your database models. Each model will be mapped to a table in the underlying database. Right now there are no models in your schema, you will explore this part in the next section.

> Note: For more information on Prisma schema, check out the [Prisma docs](https://www.prisma.io/docs/orm/prisma-schema).

#### Model the data

Now it's time to define the data models for your application. For this tutorial, you will only need an `Article` model to represent each article on the blog.

Inside the `prisma/prisma.schema` file, add a new model to your schema named `Article`:

```ts
// prisma/schema.prisma
model Article {
  id          Int      @id @default(autoincrement())
  title       String   @unique
  description String?
  body        String
  published   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

Here, you have created an `Article` model with several fields. Each field has a name (`id`, `title`, etc.), a type (`Int`, `String`, etc.), and other optional attributes (`@id`, `@unique`, etc.). Fields can be made optional by adding a `?` after the field type.

The `id` field has a special attribute called `@id`. This attribute indicates that this field is the primary key of the model. The `@default(autoincrement())` attribute indicates that this field should be automatically incremented and assigned to any newly created record.

The `published` field is a flag to indicate whether an article is published or in draft mode. The `@default(false)` attribute indicates that this field should be set to `false` by default.

The two `DateTime` fields, `createdAt` and `updatedAt`, will track when an article is created and when it was last updated. The `@updatedAt` attribute will automatically update the field with the current timestamp whenever an article is modified.date the field with the current timestamp any time an article is modified.

#### Migrate the database

With the Prisma schema defined, you will run migrations to create the actual tables in the database. To generate and execute your first migration, run the following command in the terminal:

```bash
npx prisma migrate dev --name "init"
```

This command will do three things:

1. **Save the migration**: Prisma Migrate will take a snapshot of your schema and figure out the SQL commands necessary to carry out the migration. Prisma will save the migration file containing the SQL commands to the newly created `prisma/migrations` folder.

2. **Execute the migration**: Prisma Migrate will execute the SQL in the migration file to create the underlying tables in your database.

3. **Generate Prisma Client**: Prisma will generate Prisma Client based on your latest schema. Since you did not have the Client library installed, the CLI will install it for you as well. You should see the `@prisma/client` package inside `dependencies` in your `package.json` file. Prisma Client is a TypeScript query builder auto-generated from your Prisma schema. It is tailored to your Prisma schema and will be used to send queries to the database.

> Note: You can learn more about Prisma Migrate in the [Prisma docs](https://www.prisma.io/docs/orm/prisma-migrate).

If completed successfully, you should see a message like this :

```bash
The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20220528101323_init/
    â””â”€ migration.sql

Your database is now in sync with your schema.
...
âœ” Generated Prisma Client (3.14.0 | library) to ./node_modules/@prisma/client in 31ms
```

Check the generated migration file to get an idea about what Prisma Migrate is doing behind the scenes:

```sql
-- prisma/migrations/20220528101323_init/migration.sql

-- CreateTable
CREATE TABLE "Article" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "body" TEXT NOT NULL,
    "published" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Article_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Article_title_key" ON "Article"("title");
```

> Note: The name of your migration file will be slightly different.

This is the SQL needed to create the `Article` table inside your PostgreSQL database. It was automatically generated and executed by Prisma based on your Prisma schema.

#### Seed the database

Currently, the database is empty. So you will create a seed script that will populate the database with some dummy data.

Firstly, create a seed file called `prisma/seed.ts`. This file will contain the dummy data and queries needed to seed your database.

```bash
touch prisma/seed.ts
```

Then, inside the seed file, add the following code:

```ts
// prisma/seed.ts
import { PrismaClient } from '@prisma/client';

// initialize Prisma Client
const prisma = new PrismaClient();

async function main() {
  // create two dummy articles
  const post1 = await prisma.article.upsert({
    where: { title: 'Prisma Adds Support for MongoDB' },
    update: {},
    create: {
      title: 'Prisma Adds Support for MongoDB',
      body: 'Support for MongoDB has been one of the most requested features since the initial release of...',
      description:
        "We are excited to share that today's Prisma ORM release adds stable support for MongoDB!",
      published: false,
    },
  });

  const post2 = await prisma.article.upsert({
    where: { title: "What's new in Prisma? (Q1/22)" },
    update: {},
    create: {
      title: "What's new in Prisma? (Q1/22)",
      body: 'Our engineers have been working hard, issuing new releases with many improvements...',
      description:
        'Learn about everything in the Prisma ecosystem and community from January to March 2022.',
      published: true,
    },
  });

  console.log({ post1, post2 });
}

// execute the main function
main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    // close Prisma Client at the end
    await prisma.$disconnect();
  });
```

Inside this script, you first initialize Prisma Client. Then you create two articles using the `prisma.upsert()` function. The `upsert` function will only create a new article if no article matches the `where` condition. You are using an `upsert` query instead of a `create` query because `upsert` removes errors related to accidentally trying to insert the same record twice.

You need to tell Prisma what script to execute when running the seeding command. You can do this by adding the `prisma.seed` key to the end of your `package.json` file:

```json
// package.json
// ...
  "scripts": {
    // ...
  },
  "dependencies": {
    // ...
  },
  "devDependencies": {
    // ...
  },
  "jest": {
    // ...
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
```

The `seed` command will execute the `prisma/seed.ts` script that you previously defined. This command should work automatically because `ts-node` is already installed as a dev dependency in your `package.json`.

Execute seeding with the following command:

```bash
npx prisma db seed
```

You should see the following output:

```bash
Running seed command `ts-node prisma/seed.ts` ...
{
  post1: {
    id: 1,
    title: 'Prisma Adds Support for MongoDB',
    description: "We are excited to share that today's Prisma ORM release adds stable support for MongoDB!",
    body: 'Support for MongoDB has been one of the most requested features since the initial release of...',
    published: false,
    createdAt: 2022-04-24T14:20:27.674Z,
    updatedAt: 2022-04-24T14:20:27.674Z
  },
  post2: {
    id: 2,
    title: "What's new in Prisma? (Q1/22)",
    description: 'Learn about everything in the Prisma ecosystem and community from January to March 2022.',
    body: 'Our engineers have been working hard, issuing new releases with many improvements...',
    published: true,
    createdAt: 2022-04-24T14:20:27.705Z,
    updatedAt: 2022-04-24T14:20:27.705Z
  }
}

ðŸŒ±  The seed command has been executed.
```

> Note: You can learn more about seeding in the [Prisma Docs](https://www.prisma.io/docs/orm/prisma-migrate/workflows/seeding).

#### Create a Prisma service

Inside your NestJS application, it is good practice to abstract away the Prisma Client API from your application. To do this, you will create a new service that will contain Prisma Client. This service, called `PrismaService`, will be responsible for instantiating a `PrismaClient` instance and connecting to your database.

The Nest CLI gives you an easy way to generate modules and services directly from the CLI. Run the following command in your terminal:

```bash
npx nest generate module prisma
npx nest generate service prisma
```

> Note 1: If necessary, refer to the NestJS docs for an introduction to [services](https://docs.nestjs.com/providers) and [modules](https://docs.nestjs.com/modules).

> Note 2: In some cases running the `nest generate` command with the server already running may result in NestJS throwing an exception that says: `Error: Cannot find module './app.controller'`. If you run into this error, run the following command from the terminal: `rm -rf dist` and restart the server.

This should generate a new subdirectory `./src/prisma` with a `prisma.module.ts` and `prisma.service.ts` file. The service file should contain the following code:

```ts
// src/prisma/prisma.service.ts
import { INestApplication, Injectable } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient {}
```

The Prisma module will be responsible for creating a [singleton](https://docs.nestjs.com/modules#shared-modules) instance of the `PrismaService` and allow sharing of the service throughout your application. To do this, you will add the `PrismaService` to the `exports` array in the `prisma.module.ts` file:

```ts
// src/prisma/prisma.module.ts
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

Now, any module that imports the `PrismaModule` will have access to `PrismaService` and can inject it into its own components/services. This is a common pattern for Nest.js applications.

With that out of the way, you are done setting up Prisma! You can now get to work on building the REST API.

# Set up Swagger

[Swagger](https://swagger.io/) is a tool to document your API using the [OpenAPI specification](https://github.com/OAI/OpenAPI-Specification). Nest has a dedicated module for Swagger, which you will be using shortly.

Get started by installing the required dependencies:

```bash
npm install --save @nestjs/swagger swagger-ui-express
```

Now open `main.ts` and initialize Swagger using the `SwaggerModule` class:

```ts
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const config = new DocumentBuilder()
    .setTitle('Median')
    .setDescription('The Median API description')
    .setVersion('0.1')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
}
bootstrap();
```

While the application is running, open your browser and navigate to `http://localhost:3000/api`. You should see the Swagger UI.

<Image src="https://sherbolotarbaev.pro/images/swagger-ui-example.png" alt="Swagger UI" />

# TO BE CONTINUED SOON...